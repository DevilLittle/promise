结合Promise看JS的事件循环机制(Event Loop):

一、JS是单线程
由于JS是浏览器脚本语言，主要用途是和用户互动以及操作DOM，这决定了它只能是单线程，否则会带来很复杂的同步问题。
JS是单线程，这个线程中只拥有唯一的一个事件循环。

二、任务队列
单线程意味着，所有的任务需要排队，前一个任务结束，才会执行下一个任务。

但是，如果前一个任务耗时很长，后一个任务就不得不一直等待，有时候会遇见这样的问题，很多时候CPU空闲，但是由于IO设备
（输入输出设备）很慢，比如AJAX操作从网络中读取数据，但是这时主线程完全可以不管IO设备，挂起处于等待的任务，先运行
排在后面的任务，等到IO设备返回了结果，再把挂起的任务继续执行。

所以，任务可以分成两种，一种是同步任务，另一种是异步任务。
同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；
异步任务指的是，不进入主线程、而进入"任务队列"（task queue）的任务，只有"任务队列"通知主线程，某个异步任务可以执行了，
该任务才会进入主线程执行。

（1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。

（2）主线程之外，还存在一个"任务队列"（task queue）。只要异步任务有了运行结果，就在"任务队列"之中放置一个事件。

（3）一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。

（4）主线程不断重复上面的第三步。

三、关于事件循环和任务队列的规则

* 一个线程中，事件循环是唯一的，但是任务队列可以有多个;
* 任务队列又分为macro-task（宏任务）和micro-task（微任务）;
* macro-task大概包括：script（整体代码）,setTimeout,setInterval,setImmediate,I/O,UI rendering;
* micro-task大概包括：process.nextTick,Promise,Object.observe(已废弃),MutationObserver(html5新特性)
* setTimeout/Promise等我们称之为任务源。而进入任务队列的是他们指定的具体执行任务。
* 来自不同任务源的任务会进入到不同的任务队列
* 事件循环的顺序，决定了JavaScript代码的执行顺序。它从script(整体代码)开始第一次循环。之后全局上下文进入函数调用栈。直到调用栈清空(只剩全局)，
  然后执行所有的micro-task。当所有可执行的micro-task执行完毕之后。循环再次从macro-task开始，找到其中一个任务队列执行完毕，然后再执行所有的micro-task，
  这样一直循环下去。
* 其中每一个任务的执行，无论是macro-task还是micro-task，都是借助函数调用栈来完成


setTimeout作为一个任务分发器，这个函数会立即执行，而它所要分发的任务，也就是它的第一个参数，才是延迟执行